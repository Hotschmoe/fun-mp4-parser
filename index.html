<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP4 Parser (Zig WASM)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            position: relative;
            overflow-x: hidden;
        }
        #byte-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            color: rgba(100, 100, 100, 0.1);
            font-family: monospace;
            font-size: 12px;
            overflow: hidden;
            pointer-events: none;
            white-space: pre;
            line-height: 1.5;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        h1 {
            color: #333;
        }
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            transition: border-color 0.3s;
            background-color: rgba(250, 250, 250, 0.7);
        }
        .upload-area.drag-over {
            border-color: #2196F3;
            background-color: rgba(227, 242, 253, 0.7);
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #video-container {
            margin-top: 20px;
            display: none;
        }
        video {
            max-width: 100%;
            border-radius: 4px;
        }
        #log {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: rgba(240, 240, 240, 0.7);
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .status {
            margin-top: 10px;
            color: #555;
        }
        .controls {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .controls label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .controls button {
            background-color: #f44336;
            color: white;
        }
    </style>
</head>
<body>
    <div id="byte-background"></div>
    <div class="container">
        <h1>MP4 Parser (Zig WASM)</h1>
        <p>Upload an MP4 file to parse and play it. The parser will log byte information to the console.</p>
        
        <div id="upload-area" class="upload-area">
            <p>Drag and drop an MP4 file here or</p>
            <input type="file" id="file-input" accept="video/mp4" style="display: none;">
            <button id="select-file">Select File</button>
        </div>
        
        <div class="status">
            <p id="status">WASM module loading...</p>
        </div>
        
        <div id="video-container">
            <h2>Video Playback</h2>
            <video id="video-player" controls></video>
            <div class="controls">
                <label>
                    <input type="checkbox" id="stream-bytes" checked>
                    Stream bytes during playback
                </label>
                <button id="clear-log">Clear Log</button>
            </div>
        </div>
        
        <div>
            <h2>Log Output</h2>
            <div id="log"></div>
        </div>
    </div>

    <script>
        // DOM elements
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        const selectButton = document.getElementById('select-file');
        const statusElement = document.getElementById('status');
        const videoContainer = document.getElementById('video-container');
        const videoPlayer = document.getElementById('video-player');
        const logOutput = document.getElementById('log');
        const streamBytesCheckbox = document.getElementById('stream-bytes');
        const clearLogButton = document.getElementById('clear-log');
        const byteBackground = document.getElementById('byte-background');
        
        // WASM module reference
        let zigModule = null;
        
        // Streaming state
        let streamingInterval = null;
        let currentStreamPosition = 0;
        const BYTES_PER_STREAM = 32;
        const STREAM_INTERVAL_MS = 500;
        
        // Background byte data
        let backgroundBytes = [];
        const MAX_BACKGROUND_LINES = 100;
        
        // Log messages to UI
        function logMessage(message) {
            const timestamp = new Date().toLocaleTimeString();
            logOutput.innerHTML += `[${timestamp}] ${message}\n`;
            logOutput.scrollTop = logOutput.scrollHeight;
            console.log(message);
        }
        
        // Add bytes to background
        function addToBackground(message) {
            if (message.includes(':')) {
                backgroundBytes.push(message);
                
                // Keep only the last MAX_BACKGROUND_LINES lines
                if (backgroundBytes.length > MAX_BACKGROUND_LINES) {
                    backgroundBytes.shift();
                }
                
                // Update the background
                updateByteBackground();
            }
        }
        
        // Update the byte background display
        function updateByteBackground() {
            byteBackground.textContent = backgroundBytes.join('\n');
        }
        
        // Clear the log
        function clearLog() {
            logOutput.innerHTML = '';
        }
        
        // Start streaming bytes
        function startStreamingBytes() {
            if (streamingInterval) {
                clearInterval(streamingInterval);
            }
            
            currentStreamPosition = 0;
            
            if (streamBytesCheckbox.checked && zigModule) {
                streamingInterval = setInterval(() => {
                    // Only stream if video is playing
                    if (!videoPlayer.paused) {
                        // Calculate position based on video playback progress
                        const progress = videoPlayer.currentTime / videoPlayer.duration;
                        const totalBytes = zigModule.getBufferUsed();
                        const targetPosition = Math.floor(progress * totalBytes);
                        
                        // Intercept the log output for background display
                        const originalConsoleLog = window.consoleLog;
                        window.consoleLog = (message) => {
                            addToBackground(message);
                            originalConsoleLog(message);
                        };
                        
                        // Log bytes at the current position
                        zigModule.logBytesAtPosition(targetPosition, BYTES_PER_STREAM);
                        
                        // Restore original console log
                        window.consoleLog = originalConsoleLog;
                        
                        // Update current position
                        currentStreamPosition = targetPosition + BYTES_PER_STREAM;
                    }
                }, STREAM_INTERVAL_MS);
            }
        }
        
        // Stop streaming bytes
        function stopStreamingBytes() {
            if (streamingInterval) {
                clearInterval(streamingInterval);
                streamingInterval = null;
            }
        }
        
        // Initialize WebAssembly module
        async function initWasm() {
            try {
                // Load the actual WASM file
                const wasmUrl = 'mp4_parser.wasm';
                
                // Fetch the WASM module
                const response = await fetch(wasmUrl);
                const wasmBytes = await response.arrayBuffer();
                
                // Environment imports for our Zig code
                const imports = {
                    env: {
                        consoleLog: (ptr, len) => {
                            const buffer = new Uint8Array(zigModule.memory.buffer);
                            const message = new TextDecoder().decode(buffer.subarray(ptr, ptr + len));
                            
                            // Store original console log function
                            window.consoleLog = (msg) => {
                                logMessage(msg);
                            };
                            
                            // Log message and potentially add to background
                            if (message.includes(':') && message.match(/0x[0-9A-F]+:/)) {
                                addToBackground(message);
                            }
                            logMessage(message);
                        },
                        createVideoElement: (ptr, len) => {
                            const buffer = new Uint8Array(zigModule.memory.buffer);
                            const videoData = buffer.subarray(ptr, ptr + len);
                            
                            // Create a blob and URL for the video data
                            const blob = new Blob([videoData], { type: 'video/mp4' });
                            const url = URL.createObjectURL(blob);
                            
                            // Update video player
                            videoPlayer.src = url;
                            videoContainer.style.display = 'block';
                            logMessage("Video ready for playback");
                            
                            // Setup video events
                            videoPlayer.onplay = startStreamingBytes;
                            videoPlayer.onpause = stopStreamingBytes;
                            videoPlayer.onended = stopStreamingBytes;
                        }
                    }
                };
                
                // Instantiate the WebAssembly module
                const { instance } = await WebAssembly.instantiate(wasmBytes, imports);
                zigModule = instance.exports;
                
                // Now that the module is loaded, update the UI
                statusElement.textContent = "WASM module loaded. Ready to process MP4 files.";
                logMessage("MP4 Parser initialized");
                
                // Enable file input after module is ready
                selectButton.disabled = false;
            } catch (error) {
                statusElement.textContent = "Failed to load WASM module: " + error.message;
                console.error("WASM initialization error:", error);
            }
        }
        
        // Handle file selection
        function handleFile(file) {
            if (!file || !file.type.includes('mp4')) {
                logMessage("Please select a valid MP4 file");
                return;
            }
            
            // Reset state
            zigModule.resetBuffer();
            videoPlayer.src = '';
            videoContainer.style.display = 'none';
            stopStreamingBytes();
            backgroundBytes = [];
            updateByteBackground();
            
            statusElement.textContent = `Processing: ${file.name} (${(file.size / (1024 * 1024)).toFixed(2)} MB)`;
            
            // Read file in chunks using FileReader
            const chunkSize = 1024 * 1024; // 1MB chunks
            let offset = 0;
            
            function readNextChunk() {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const chunk = new Uint8Array(e.target.result);
                    
                    // Copy the chunk data to the WebAssembly memory
                    // First, get a pointer to the WebAssembly memory
                    const wasmMemory = new Uint8Array(zigModule.memory.buffer);
                    
                    // Copy the chunk data to the WebAssembly memory
                    for (let i = 0; i < chunk.length; i++) {
                        wasmMemory[i] = chunk[i];
                    }
                    
                    // Call the addData function with the pointer and length
                    zigModule.addData(0, chunk.length);
                    
                    // Update progress
                    offset += chunk.length;
                    const progress = Math.min(100, Math.round((offset / file.size) * 100));
                    statusElement.textContent = `Processing: ${file.name} (${progress}%)`;
                    
                    // Continue reading chunks
                    if (offset < file.size) {
                        readNextChunk();
                    } else {
                        // Done reading the file
                        statusElement.textContent = `Parsing complete: ${file.name}`;
                        
                        // Parse the MP4 file
                        zigModule.parseMP4();
                        
                        // Log some bytes for demonstration and add to background
                        const originalConsoleLog = window.consoleLog;
                        window.consoleLog = (message) => {
                            addToBackground(message);
                            originalConsoleLog(message);
                        };
                        
                        zigModule.logBytes(128);
                        
                        // Restore original console log
                        window.consoleLog = originalConsoleLog;
                    }
                };
                
                reader.onerror = function() {
                    statusElement.textContent = "Error reading file";
                    logMessage("File read error");
                };
                
                // Read a slice of the file
                const slice = file.slice(offset, offset + chunkSize);
                reader.readAsArrayBuffer(slice);
            }
            
            // Start reading the file
            readNextChunk();
        }
        
        // Event listeners
        selectButton.addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        // Clear log button
        clearLogButton.addEventListener('click', clearLog);
        
        // Stream bytes checkbox
        streamBytesCheckbox.addEventListener('change', () => {
            if (streamBytesCheckbox.checked) {
                startStreamingBytes();
            } else {
                stopStreamingBytes();
            }
        });
        
        // Drag and drop handling
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });
        
        // Initialize the application
        window.addEventListener('load', () => {
            selectButton.disabled = true; // Disable until WASM loads
            initWasm();
        });
    </script>
</body>
</html>