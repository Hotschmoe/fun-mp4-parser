<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP4 Parser (Zig WASM)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #byte-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            color: rgba(60, 60, 60, 0.2);
            font-family: monospace;
            overflow: hidden;
            pointer-events: none;
            box-sizing: border-box;
            padding: 0;
            margin: 0;
        }
        #byte-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            box-sizing: border-box;
            padding: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }
        .byte-line {
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: center;
            opacity: 1;
        }
        .container {
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            max-width: 500px;
            width: 90%;
            z-index: 1;
        }
        h1 {
            color: #333;
            margin-top: 0;
            font-size: 1.5rem;
            text-align: center;
        }
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            transition: border-color 0.3s;
            background-color: rgba(250, 250, 250, 0.7);
        }
        .upload-area.drag-over {
            border-color: #2196F3;
            background-color: rgba(227, 242, 253, 0.7);
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #video-container {
            margin-top: 15px;
            display: none;
        }
        video {
            width: 100%;
            border-radius: 4px;
            background-color: #000;
        }
        .status {
            margin-top: 10px;
            color: #555;
            font-size: 0.9rem;
            text-align: center;
        }
        .controls {
            display: none;
        }
        .speed-control {
            display: none;
        }
    </style>
</head>
<body>
    <div id="byte-background">
        <div id="byte-content"></div>
    </div>
    <div class="container">
        <h1>MP4 Parser</h1>
        
        <div id="upload-area" class="upload-area">
            <p>Drop MP4 file here</p>
            <input type="file" id="file-input" accept="video/mp4" style="display: none;">
            <button id="select-file">Select File</button>
        </div>
        
        <div class="status">
            <p id="status">WASM module loading...</p>
        </div>
        
        <div id="video-container">
            <video id="video-player" controls></video>
        </div>
    </div>

    <script>
        // DOM elements
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        const selectButton = document.getElementById('select-file');
        const statusElement = document.getElementById('status');
        const videoContainer = document.getElementById('video-container');
        const videoPlayer = document.getElementById('video-player');
        const byteBackground = document.getElementById('byte-background');
        const byteContent = document.getElementById('byte-content');
        
        // WASM module reference
        let zigModule = null;
        
        // Streaming state
        let streamingActive = false;
        let animationFrameId = null;
        let lastTimestamp = 0;
        let currentStreamPosition = 0;
        const BYTES_PER_STREAM = 8; // Smaller chunks for smoother streaming
        
        // Background byte data
        let backgroundBytes = [];
        let pendingBytes = [];
        let isProcessingBytes = false;
        const MAX_BACKGROUND_LINES = 300;
        
        // Calculate how many characters fit in a line
        function calculateCharsPerLine() {
            const testElement = document.createElement('span');
            testElement.style.fontFamily = 'monospace';
            testElement.style.fontSize = byteContent.style.fontSize;
            testElement.style.visibility = 'hidden';
            testElement.textContent = 'X';
            document.body.appendChild(testElement);
            
            const charWidth = testElement.getBoundingClientRect().width;
            document.body.removeChild(testElement);
            
            // Add a small buffer to account for reduced padding
            return Math.floor(window.innerWidth / charWidth) - 2;
        }
        
        // Calculate how many lines fit in the viewport
        function calculateLinesInViewport() {
            const testElement = document.createElement('div');
            testElement.style.fontFamily = 'monospace';
            testElement.style.fontSize = byteContent.style.fontSize;
            testElement.style.visibility = 'hidden';
            testElement.textContent = 'X';
            document.body.appendChild(testElement);
            
            const lineHeight = testElement.getBoundingClientRect().height;
            document.body.removeChild(testElement);
            
            return Math.floor(window.innerHeight / lineHeight);
        }
        
        // Adjust font size to fill the screen
        function adjustFontSize() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Calculate font size based on window dimensions - doubled
            const baseFontSize = Math.min(windowWidth / 40, windowHeight / 20);
            byteContent.style.fontSize = `${baseFontSize}px`;
            
            // Update the background to fill the screen
            updateByteBackground();
        }
        
        // Log messages to console only
        function logMessage(message) {
            console.log(message);
        }
        
        // Add bytes to background queue
        function addToBackground(message) {
            if (message.includes(':')) {
                // Pad the message to fill the entire width
                const charsPerLine = calculateCharsPerLine();
                const paddedMessage = padMessageToWidth(message, charsPerLine);
                
                // Add to pending queue
                pendingBytes.push(paddedMessage);
                
                // Start processing if not already
                if (!isProcessingBytes) {
                    processNextByte();
                }
            }
        }
        
        // Process next byte from the queue
        function processNextByte() {
            if (pendingBytes.length === 0) {
                isProcessingBytes = false;
                return;
            }
            
            isProcessingBytes = true;
            const nextByte = pendingBytes.shift();
            
            // Add to background
            backgroundBytes.push(nextByte);
            
            // Keep only the last MAX_BACKGROUND_LINES lines
            if (backgroundBytes.length > MAX_BACKGROUND_LINES) {
                backgroundBytes.shift();
            }
            
            // Update the background
            updateByteBackground();
            
            // Process next byte immediately
            if (pendingBytes.length > 0) {
                setTimeout(processNextByte, 20); // Small delay to prevent UI blocking
            } else {
                isProcessingBytes = false;
            }
        }
        
        // Pad a message to fill the entire width
        function padMessageToWidth(message, width) {
            // Ensure all messages are the same length by truncating or padding
            if (message.length > width) {
                // Truncate if too long
                return message.substring(0, width);
            }
            
            // Calculate padding needed on each side
            const totalPadding = width - message.length;
            const leftPadding = Math.floor(totalPadding / 2);
            
            // Use minimal padding to get closer to the edges
            return ' '.repeat(Math.max(1, leftPadding / 4)) + message + ' '.repeat(Math.max(1, (totalPadding - leftPadding) / 4));
        }
        
        // Update the byte background display
        function updateByteBackground() {
            byteContent.innerHTML = '';
            
            // Calculate visible lines
            const visibleLines = calculateLinesInViewport();
            const startIndex = Math.max(0, backgroundBytes.length - visibleLines);
            
            // Add empty lines at the top if needed
            if (backgroundBytes.length < visibleLines) {
                const emptyLines = visibleLines - backgroundBytes.length;
                for (let i = 0; i < emptyLines; i++) {
                    const emptyLine = document.createElement('div');
                    emptyLine.className = 'byte-line';
                    emptyLine.innerHTML = '&nbsp;';
                    byteContent.appendChild(emptyLine);
                }
            }
            
            // Add actual content lines
            for (let i = startIndex; i < backgroundBytes.length; i++) {
                const lineElement = document.createElement('div');
                lineElement.className = 'byte-line';
                lineElement.textContent = backgroundBytes[i];
                
                byteContent.appendChild(lineElement);
            }
        }
        
        // Clear the background
        function clearBackground() {
            backgroundBytes = [];
            pendingBytes = [];
            isProcessingBytes = false;
            updateByteBackground();
        }
        
        // Start streaming bytes in real time
        function startStreamingBytes() {
            if (streamingActive) {
                return;
            }
            
            // Clear any existing background bytes first
            clearBackground();
            
            streamingActive = true;
            currentStreamPosition = 0;
            lastTimestamp = 0;
            
            // Start the animation frame loop for real-time streaming
            function streamFrame(timestamp) {
                if (!streamingActive || videoPlayer.paused) {
                    streamingActive = false;
                    return;
                }
                
                // Calculate time delta and decide if we should stream
                // We'll stream bytes based on video playback position
                const progress = videoPlayer.currentTime / videoPlayer.duration;
                const totalBytes = zigModule.getBufferUsed();
                const targetPosition = Math.floor(progress * totalBytes);
                
                // Only log if position has changed enough
                if (Math.abs(targetPosition - currentStreamPosition) > BYTES_PER_STREAM) {
                    // Intercept the log output for background display
                    const originalConsoleLog = window.consoleLog;
                    window.consoleLog = (message) => {
                        addToBackground(message);
                        if (originalConsoleLog) originalConsoleLog(message);
                    };
                    
                    // Log bytes at the current position
                    zigModule.logBytesAtPosition(targetPosition, BYTES_PER_STREAM);
                    
                    // Restore original console log
                    window.consoleLog = originalConsoleLog;
                    
                    // Update current position
                    currentStreamPosition = targetPosition;
                }
                
                // Request next frame
                animationFrameId = requestAnimationFrame(streamFrame);
            }
            
            // Start the animation frame loop
            animationFrameId = requestAnimationFrame(streamFrame);
        }
        
        // Stop streaming bytes
        function stopStreamingBytes() {
            streamingActive = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        // Initialize WebAssembly module
        async function initWasm() {
            try {
                // Load the actual WASM file
                const wasmUrl = 'mp4_parser.wasm';
                
                // Fetch the WASM module
                const response = await fetch(wasmUrl);
                const wasmBytes = await response.arrayBuffer();
                
                // Environment imports for our Zig code
                const imports = {
                    env: {
                        consoleLog: (ptr, len) => {
                            const buffer = new Uint8Array(zigModule.memory.buffer);
                            const message = new TextDecoder().decode(buffer.subarray(ptr, ptr + len));
                            
                            // Store original console log function
                            window.consoleLog = (msg) => {
                                console.log(msg);
                            };
                            
                            // Only add to background if we're actively streaming
                            // and it's a byte format message (contains hex address)
                            if (streamingActive && message.includes(':') && message.match(/0x[0-9A-F]+:/)) {
                                addToBackground(message);
                            }
                            console.log(message);
                        },
                        createVideoElement: (ptr, len) => {
                            const buffer = new Uint8Array(zigModule.memory.buffer);
                            const videoData = buffer.subarray(ptr, ptr + len);
                            
                            // Create a blob and URL for the video data
                            const blob = new Blob([videoData], { type: 'video/mp4' });
                            const url = URL.createObjectURL(blob);
                            
                            // Update video player
                            videoPlayer.src = url;
                            videoContainer.style.display = 'block';
                            uploadArea.style.display = 'none';
                            logMessage("Video ready for playback");
                            
                            // Setup video events
                            videoPlayer.onplay = startStreamingBytes;
                            videoPlayer.onpause = stopStreamingBytes;
                            videoPlayer.onended = stopStreamingBytes;
                        }
                    }
                };
                
                // Instantiate the WebAssembly module
                const { instance } = await WebAssembly.instantiate(wasmBytes, imports);
                zigModule = instance.exports;
                
                // Now that the module is loaded, update the UI
                statusElement.textContent = "Ready to process MP4 files";
                logMessage("MP4 Parser initialized");
                
                // Enable file input after module is ready
                selectButton.disabled = false;
            } catch (error) {
                statusElement.textContent = "Failed to load WASM module: " + error.message;
                console.error("WASM initialization error:", error);
            }
        }
        
        // Handle file selection
        function handleFile(file) {
            if (!file || !file.type.includes('mp4')) {
                logMessage("Please select a valid MP4 file");
                return;
            }
            
            // Reset state
            zigModule.resetBuffer();
            videoPlayer.src = '';
            videoContainer.style.display = 'none';
            uploadArea.style.display = 'block';
            stopStreamingBytes();
            clearBackground();
            
            statusElement.textContent = `Processing: ${file.name}`;
            
            // Read file in chunks using FileReader
            const chunkSize = 1024 * 1024; // 1MB chunks
            let offset = 0;
            
            function readNextChunk() {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const chunk = new Uint8Array(e.target.result);
                    
                    // Copy the chunk data to the WebAssembly memory
                    // First, get a pointer to the WebAssembly memory
                    const wasmMemory = new Uint8Array(zigModule.memory.buffer);
                    
                    // Copy the chunk data to the WebAssembly memory
                    for (let i = 0; i < chunk.length; i++) {
                        wasmMemory[i] = chunk[i];
                    }
                    
                    // Call the addData function with the pointer and length
                    zigModule.addData(0, chunk.length);
                    
                    // Update progress
                    offset += chunk.length;
                    const progress = Math.min(100, Math.round((offset / file.size) * 100));
                    statusElement.textContent = `Processing: ${progress}%`;
                    
                    // Continue reading chunks
                    if (offset < file.size) {
                        readNextChunk();
                    } else {
                        // Done reading the file
                        statusElement.textContent = `Ready to play`;
                        
                        // Parse the MP4 file
                        zigModule.parseMP4();
                        
                        // Don't log initial bytes - we'll only show streaming bytes
                        // when the video plays
                    }
                };
                
                reader.onerror = function() {
                    statusElement.textContent = "Error reading file";
                    logMessage("File read error");
                };
                
                // Read a slice of the file
                const slice = file.slice(offset, offset + chunkSize);
                reader.readAsArrayBuffer(slice);
            }
            
            // Start reading the file
            readNextChunk();
        }
        
        // Event listeners
        selectButton.addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        // Drag and drop handling
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });
        
        // Window resize event
        window.addEventListener('resize', () => {
            adjustFontSize();
        });
        
        // Initialize the application
        window.addEventListener('load', () => {
            selectButton.disabled = true; // Disable until WASM loads
            adjustFontSize(); // Set initial font size
            initWasm();
        });
    </script>
</body>
</html>